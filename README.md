# Домашнее задание к занятию "`Базы данных, их типы`" - `Осаковская Анна`

---

### Задание 1

**1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков. СУБД должна гарантировать целостность и чёткую структуру данных**

**Выбранный тип СУБД**: Реляционная СУБД (SQL) - Oracle, MySQL, PostgreSQL

Реляционные СУБД основаны на ACID-транзакциях (Atomicity, Consistency, Isolation, Durability), что гарантирует точность и надежность финансовых данных. Строгая схема данных (предопределенные таблицы, столбцы, типы данных, связи) исключает аномалии и обеспечивает четкую структуру, необходимую для бухгалтерского учета и отчетности. Хорошо подходят для сложных запросов с джойнами (JOIN) и агрегациями, которые требуются для формирования аналитики. Поддерживает интеграцию с BI-инструментами (Power BI, Tableau).

**1.1. * Хеширование стало занимать длительно время, какое API можно использовать для ускорения работы?**

Проблема с хешированием указывает на неэффективность встроенных функций СУБД и (или) высокую нагрузку. 

**Решение**: вынести операции на уровень приложения.

API/Библиотеки:
- Для криптографических целей (пароли, данные): passlib, bcrypt, cryptography, bcrypt, crypto, Bouncy Castle, Spring Security Crypto;
- Для проверки целостности больших данных (расчет MD5, SHA-256 для больших файлов или BLOB-объектов): OpenSSL API, Crypto++, Web Crypto API;
- Для хеш-таблиц и поиска дубликатов: xxHash, MurmurHash3, CityHash, FarmHash;
- При высоких нагрузках (тысячи операций в секунду): Intel IPP (Integrated Performance Primitives), GPU-ускорение через CUDA/OpenCL, специализированные HSM (Hardware Security Modules) для криптографических операций.

**1.2. Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам. Какой тип СУБД лучше использовать для лендингов и для CRM? СУБД должны быть гибкими и быстрыми**

**Выбранный тип СУБД**: Документная NoSQL СУБД - MongoDB, Couchbase

Данные с лендингов могут меняться (добавляются новые поля для сбора информации). Документная модель позволяет хранить данные по лидам в виде JSON-документов, структура которых может легко изменяться без дорогостоящих миграций схемы БД. Отлично справляются с операциями записи и чтения по ключу или простым запросам, что хорошо подходит для трекинга лидов в реальном времени. Легко масштабируются горизонтально для обработки большого потока лидов с множества лендингов.

**1.2. * Можно ли эту задачу закрыть одной СУБД? И если да, то какой именно СУБД и какой реализацией?**

**Решение**: да, можно. Для решения обеих задач предлагается использовать **MongoDB**

Реализация:
- Создать отдельные коллекции (collections) внутри одной базы данных MongoDB: например, leads для данных с лендингов и clients / deals для данных CRM;
- Использовать единый API для записи данных с лендингов и для работы менеджеров в CRM-системе.

**1.3. Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании. СУБД должна иметь простую и понятную структуру.**

**Выбранный тип СУБД**: Графовая СУБД (Neo4j, Apache Age, JanusGraph, yDB)

Графовые СУБД хорошо моделируют иерархические и связанные данные. Элементы базы знаний (нормы, правила, обучающие материалы) можно представить как узлы, а связи между ними (например, "относится к определенному подразделению", "является предварительным условием для", "ссылается на") — как рёбра.
Для поиска связанной информации (например, "найти все правила, связанные с техникой безопасности на высоте") не требуются сложные JOIN-запросы, как в реляционных базах.

**1.3. * Можно ли под эту задачу использовать уже существующую СУБД из задач выше?**

**Решение**: Технически да, но это будет неэффективно. Для максимальной эффективности и простоты работы со связями лучше использовать специализированную графовую СУБД.

**MongoDB (из пункта 1.2)**: Можно хранить документы с материалами, но ссылки между ними прийдется поддерживать вручную. Возможности для работы со связями будут слабее, чем у графовой СУБД. Запросы на поиск сложных связей влекут большие трудозатраты и не являются тревиальными.

**PostgreSQL (из пункта 1.1)**: Можно создать таблицы для материалов и таблицу связей. Это будет работать лучше, чем в MongoDB, но всё равно уступит в производительности и простоте графовой СУБД для глубоких обходов связей.

**1.4. Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов. СУБД должна уметь быстро работать со связями**

**Выбранный тип СУБД**: Графовая СУБД (Neo4j, OrientDB)

Работа со связями - это классическая задача для графовой СУБД. Графовые базы данных наиболее эффективны для алгоритмов на графах, например, поиск кратчайшего пути.

**1.4. * Можно ли к этой СУБД подключить отдел закупок или для них лучше сформировать свою СУБД в связке с СУБД логистов?**

**Решение**: да, можно

Графовую модель можно расширить

Узлы: Поставщики, Материалы, Склады, Объекты, Курьеры.

Связи: Поставляет_от (Поставщик -> Материал), Расположен_на (Материал -> Склад), Требуется_на (Материал -> Объект).

**1.5. * Можно ли все перечисленные выше задачи решить, используя одну СУБД? Если да, то какую именно?**

**Решение**: Технически да, но это будет неэффективно.

В качестве единой СУБД можно выбрать **PostgreSQL** (самая продвинутая из open-source СУБД с большим количеством расширений)

Плюсы:
-  Снижение операционных издержек (администрирование одной системы);
-  Упрощение создания резервных копий и обеспечения согласованности в рамках одной системы;
-  Возможность делать JOIN между данными из разных предметных областей (например, финансовые отчеты и данные по лидам).

Минусы (существенные):
- Единая точка отказа (проблемы с производительностью или сбои в одной области повлияют на все остальные);
- Сложность масштабирования (cложнее масштабировать разные типы нагрузок независимо друг от друга);
- Производительность (специализированная СУБД всегда будет работать лучше для своей узкой задачи, чем универсальная).

---

### Задание 2

**2.1. Обычное пополнение баланса**

**1. Инициация транзакции.** Система фиксирует начало операции.

**2. Проверка и блокировка счёта.** Система проверяет существование и активность счёта. На запись счёта в базе данных накладывается так называемая пессимистическая блокировка (pessimistic lock) для обеспечения согласованности данных при параллельных операциях.

**3. Списание средств с платёжного инструмента.** Производится попытка списания через платёжный шлюз. В случае неудачи транзакция полностью откатывается.

**4. Зачисление средств на счёт телефона.** После успешного списания сумма зачисляется на баланс.

**5. Фиксация транзакции (Commit). Система подтверждает успешное выполнение всех шагов. Изменения (новый баланс) окончательно сохраняются в базу данных, блокировки со счёта снимаются.

**6. Уведомление пользователя.** Пользователю отправляется сообщение об успешном пополнении счёта.


**2.1. * Пополнение через автоплатёж**

**1. Запуск по расписанию.** Планировщик задач инициирует обработку всех автоплатежей, запланированных на текущую дату.

**2. Начало транзакции для автоплатежа.** Для каждого автоплатежа начинается отдельная транзакция.

**3. Проверка условий и блокировка.** Система проверяет активность автоплатежа, его лимиты и привязанный платёжный инструмент. Счёт пользователя блокируется для изменений.

**4.Списание средств и обработка результата.**

В случае успеха: Система переходит к шагу 5.

В случае неудачи: В рамках этой же транзакции система обновляет статус автоплатежа (например, на "Ошибка") и увеличивает счётчик неудачных попыток. После этого транзакция завершается откатом (rollback).

**5. Зачисление средств и обновление автоплатежа.** Средства зачисляются на счёт, а запись автоплатежа обновляется (дата последнего выполнения, следующий платёж). Транзакция фиксируется (commit).

**6. Логирование и уведомление (вне транзакции).** Система логирует итог операции и асинхронно отправляет пользователю уведомление о результате ("Успешно" / "Не удалось").

---

### Задание 3

**3.1. Пять преимуществ SQL перед NoSQL:**

**1. Стандартизированный язык (SQL)** — мощный и универсальный для сложных запросов.

**2. Строгая согласованность данных (ACID)** — гарантирует целостность и надежность транзакций.

**3. Сложные JOIN-запросы** — удобство для анализа связанных данных из разных таблиц.

**4. Зрелость и стабильность** — проверенная временем технология, надежность и богатый инструментарий.

**5. Схемо-ориентированность** — четкая структура данных предотвращает аномалии и улучшает документирование.


**3.1. * Преимущества NewSQL перед SQL и NoSQL:**

**Масштабируемость SQL**: сочетает горизонтальную масштабируемость, как у NoSQL, с ACID-гарантиями реляционных СУБД.

**Производительность**: за счет архитектурных улучшений (например, размещение данных в оперативной памяти) превосходит традиционные SQL-системы в OLTP-нагрузках.

**Объединяет главные плюсы обеих систем**: предлагает строгую согласованность и мощь SQL, но без сложностей шардинга (разделения одной большой базы данных на несколько меньших частей), характерных для классических реляционных баз, и без потери согласованности, как в NoSQL.

### Задание 4

**Критерий выбора СУБД:**

- Характер данных и запросов (структурированные/неструктурированные, OLAP vs OLTP);

- Требования к масштабированию (поддержка горизонтального масштабирования на 1000 узлов);

- Согласованность данных (возможность ослабления для производительности).

**Модель распределённых вычислений:**

Лучшая модель - MapReduce (например, в Hadoop/Spark):

- Оптимизирована для обработки больших данных на сотнях/тысячах узлов;

- Обеспечивает отказоустойчивость и параллелизм;

- Подходит для пакетной обработки, когда важна пропускная способность, а не низкая задержка.

**Альтернатива:**

Для интерактивной аналитики, когда нужно быстро получать ответы на сложные запросы по огромным данным, хорошим решением является MPP-СУБД (ClickHouse, BigQuery) с массовой параллельной обработкой запросов.
